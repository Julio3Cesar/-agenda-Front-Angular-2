"use strict";
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
Object.defineProperty(exports, "__esModule", { value: true });
var injector_1 = require("../di/injector");
var ng_module_factory_1 = require("../linker/ng_module_factory");
var util_1 = require("./util");
var NOT_CREATED = new Object();
var InjectorRefTokenKey = util_1.tokenKey(injector_1.Injector);
var NgModuleRefTokenKey = util_1.tokenKey(ng_module_factory_1.NgModuleRef);
function moduleProvideDef(flags, token, value, deps) {
    var depDefs = util_1.splitDepsDsl(deps);
    return {
        // will bet set by the module definition
        index: -1,
        deps: depDefs, flags: flags, token: token, value: value
    };
}
exports.moduleProvideDef = moduleProvideDef;
function moduleDef(providers) {
    var providersByKey = {};
    for (var i = 0; i < providers.length; i++) {
        var provider = providers[i];
        provider.index = i;
        providersByKey[util_1.tokenKey(provider.token)] = provider;
    }
    return {
        // Will be filled later...
        factory: null,
        providersByKey: providersByKey,
        providers: providers
    };
}
exports.moduleDef = moduleDef;
function initNgModule(data) {
    var def = data._def;
    var providers = data._providers = new Array(def.providers.length);
    for (var i = 0; i < def.providers.length; i++) {
        var provDef = def.providers[i];
        providers[i] = provDef.flags & 4096 /* LazyProvider */ ? NOT_CREATED :
            _createProviderInstance(data, provDef);
    }
}
exports.initNgModule = initNgModule;
function resolveNgModuleDep(data, depDef, notFoundValue) {
    if (notFoundValue === void 0) { notFoundValue = injector_1.Injector.THROW_IF_NOT_FOUND; }
    if (depDef.flags & 8 /* Value */) {
        return depDef.token;
    }
    if (depDef.flags & 2 /* Optional */) {
        notFoundValue = null;
    }
    if (depDef.flags & 1 /* SkipSelf */) {
        return data._parent.get(depDef.token, notFoundValue);
    }
    var tokenKey = depDef.tokenKey;
    switch (tokenKey) {
        case InjectorRefTokenKey:
        case NgModuleRefTokenKey:
            return data;
    }
    var providerDef = data._def.providersByKey[tokenKey];
    if (providerDef) {
        var providerInstance = data._providers[providerDef.index];
        if (providerInstance === NOT_CREATED) {
            providerInstance = data._providers[providerDef.index] =
                _createProviderInstance(data, providerDef);
        }
        return providerInstance;
    }
    return data._parent.get(depDef.token, notFoundValue);
}
exports.resolveNgModuleDep = resolveNgModuleDep;
function _createProviderInstance(ngModule, providerDef) {
    var injectable;
    switch (providerDef.flags & 201347067 /* Types */) {
        case 512 /* TypeClassProvider */:
            injectable = _createClass(ngModule, providerDef.value, providerDef.deps);
            break;
        case 1024 /* TypeFactoryProvider */:
            injectable = _callFactory(ngModule, providerDef.value, providerDef.deps);
            break;
        case 2048 /* TypeUseExistingProvider */:
            injectable = resolveNgModuleDep(ngModule, providerDef.deps[0]);
            break;
        case 256 /* TypeValueProvider */:
            injectable = providerDef.value;
            break;
    }
    return injectable;
}
function _createClass(ngModule, ctor, deps) {
    var len = deps.length;
    var injectable;
    switch (len) {
        case 0:
            injectable = new ctor();
            break;
        case 1:
            injectable = new ctor(resolveNgModuleDep(ngModule, deps[0]));
            break;
        case 2:
            injectable =
                new ctor(resolveNgModuleDep(ngModule, deps[0]), resolveNgModuleDep(ngModule, deps[1]));
            break;
        case 3:
            injectable = new ctor(resolveNgModuleDep(ngModule, deps[0]), resolveNgModuleDep(ngModule, deps[1]), resolveNgModuleDep(ngModule, deps[2]));
            break;
        default:
            var depValues = new Array(len);
            for (var i = 0; i < len; i++) {
                depValues[i] = resolveNgModuleDep(ngModule, deps[i]);
            }
            injectable = new (ctor.bind.apply(ctor, [void 0].concat(depValues)))();
    }
    return injectable;
}
function _callFactory(ngModule, factory, deps) {
    var len = deps.length;
    var injectable;
    switch (len) {
        case 0:
            injectable = factory();
            break;
        case 1:
            injectable = factory(resolveNgModuleDep(ngModule, deps[0]));
            break;
        case 2:
            injectable =
                factory(resolveNgModuleDep(ngModule, deps[0]), resolveNgModuleDep(ngModule, deps[1]));
            break;
        case 3:
            injectable = factory(resolveNgModuleDep(ngModule, deps[0]), resolveNgModuleDep(ngModule, deps[1]), resolveNgModuleDep(ngModule, deps[2]));
            break;
        default:
            var depValues = Array(len);
            for (var i = 0; i < len; i++) {
                depValues[i] = resolveNgModuleDep(ngModule, deps[i]);
            }
            injectable = factory.apply(void 0, depValues);
    }
    return injectable;
}
function callNgModuleLifecycle(ngModule, lifecycles) {
    var def = ngModule._def;
    for (var i = 0; i < def.providers.length; i++) {
        var provDef = def.providers[i];
        if (provDef.flags & 131072 /* OnDestroy */) {
            var instance = ngModule._providers[i];
            if (instance && instance !== NOT_CREATED) {
                instance.ngOnDestroy();
            }
        }
    }
}
exports.callNgModuleLifecycle = callNgModuleLifecycle;
//# sourceMappingURL=ng_module.js.map