"use strict";
require('reflect-metadata');
var ts = require('typescript');
var service_1 = require('../src/service');
var typescript_host_1 = require('../src/typescript_host');
var test_data_1 = require('./test_data');
var test_utils_1 = require('./test_utils');
describe('service', function () {
    var documentRegistry = ts.createDocumentRegistry();
    var mockHost = new test_utils_1.MockTypescriptHost(['/app/main.ts', '/app/parsing-cases.ts'], test_data_1.toh);
    var service = ts.createLanguageService(mockHost, documentRegistry);
    var program = service.getProgram();
    var ngHost = new typescript_host_1.TypeScriptServiceHost(ts, mockHost, service, "");
    var ngService = service_1.createLanguageService(ngHost);
    it('should be able to get template references', function () {
        expect(function () { return ngService.getTemplateReferences(); }).not.toThrow();
    });
    it('should be able to determine that test.ng is a template reference', function () {
        expect(ngService.getTemplateReferences()).toContain('/app/test.ng');
    });
    it('should be no diagnostics for test.ng', function () {
        expect(ngService.getDiagnostics('/app/test.ng')).toEqual([]);
    });
    it('should be able to get entity completions', function () {
        contains('/app/test.ng', 'entity-amp', '&amp;', '&gt;', '&lt;', '&iota;');
    });
    it('should be able to return html elements', function () {
        var htmlTags = ['h1', 'h2', 'div', 'span'];
        var locations = ['empty', 'start-tag-h1', 'h1-content', 'start-tag', 'start-tag-after-h'];
        for (var _i = 0, locations_1 = locations; _i < locations_1.length; _i++) {
            var location_1 = locations_1[_i];
            contains.apply(void 0, ['/app/test.ng', location_1].concat(htmlTags));
        }
    });
    it('should be able to return element diretives', function () { contains('/app/test.ng', 'empty', 'my-app'); });
    it('should be able to return h1 attributes', function () { contains('/app/test.ng', 'h1-after-space', 'id', 'dir', 'lang', 'onclick'); });
    it('should be able to find common angular attributes', function () {
        contains('/app/test.ng', 'div-attributes', '(click)', '[ngClass]');
    });
    it('should be able to get completions in some random garbage', function () {
        var fileName = '/app/test.ng';
        mockHost.override(fileName, " > {{tle<\n  {{retl  ><bel/beled}}di>\n   la</b  </d    &a  ");
        expect(function () { return ngService.getCompletionsAt(fileName, 31); }).not.toThrow();
        mockHost.override(fileName, undefined);
    });
    describe('for semantic errors', function () {
        var fileName = '/app/test.ng';
        function diagnostics(template) {
            try {
                mockHost.override(fileName, template);
                return ngService.getDiagnostics(fileName).get(fileName);
            }
            finally {
                mockHost.override(fileName, undefined);
            }
        }
        function accept(template) {
            noDiagnostics(diagnostics(template));
        }
        function reject(template, message, at, len) {
            if (typeof at == 'string') {
                len = at.length;
                at = template.indexOf(at);
            }
            includeDiagnostic(diagnostics(template), message, at, len);
        }
        describe('with $event', function () {
            it('should accept an event', function () {
                accept('<div (click)="myClick($event)">Click me!</div>');
            });
            it('should reject it when not in an event binding', function () {
                reject('<div [tabIndex]="$event"></div>', "'$event' is not defined", '$event');
            });
        });
    });
    it('should be able to complete every character in the file', function () {
        var fileName = '/app/test.ng';
        expect(function () {
            var chance = 0.05;
            var requests = 0;
            function tryCompletionsAt(position) {
                try {
                    if (Math.random() < chance) {
                        ngService.getCompletionsAt(fileName, position);
                        requests++;
                    }
                }
                catch (e) {
                    // Emit enough diagnostic information to reproduce the error.
                    console.log("Position: " + position + "\nContent: \"" + mockHost.getFileContent(fileName) + "\"\nStack:\n" + e.stack);
                    throw e;
                }
            }
            try {
                var originalContent = mockHost.getFileContent(fileName);
                // For each character in the file, add it to the file and request a completion after it.
                for (var index = 0, len = originalContent.length; index < len; index++) {
                    var content_1 = originalContent.substr(0, index);
                    mockHost.override(fileName, content_1);
                    tryCompletionsAt(index);
                }
                // For the complete file, try to get a completion at every character.
                mockHost.override(fileName, originalContent);
                for (var index = 0, len = originalContent.length; index < len; index++) {
                    tryCompletionsAt(index);
                }
                // Delete random characters in the file until we get an empty file.
                var content = originalContent;
                while (content.length > 0) {
                    var deleteIndex = Math.floor(Math.random() * content.length);
                    content = content.slice(0, deleteIndex - 1) + content.slice(deleteIndex + 1);
                    mockHost.override(fileName, content);
                    var requestIndex = Math.floor(Math.random() * content.length);
                    tryCompletionsAt(requestIndex);
                }
                // Build up the string from zero asking for a completion after every char
                buildUp(originalContent, function (text, position) {
                    mockHost.override(fileName, text);
                    tryCompletionsAt(position);
                });
            }
            finally {
                mockHost.override(fileName, undefined);
            }
        }).not.toThrow();
    });
    describe('with regression tests', function () {
        it('should not crash with an incomplete component', function () {
            expect(function () {
                var code = "\n@Component({\n  template: '~{inside-template}'\n})\nexport class MyComponent {\n\n}";
                addCode(code, function (fileName) {
                    contains(fileName, 'inside-template', 'h1');
                });
            }).not.toThrow();
        });
        it('should hot crash with an incomplete class', function () {
            expect(function () {
                addCode('\nexport class', function (fileName) {
                    //ngHost.updateModuleSummary();
                });
            }).not.toThrow();
        });
        it('should not crash with a incomplete *ngFor', function () {
            expect(function () {
                var code = "\n@Component({template: '<div *ngFor></div> ~{after-div}'}) export class MyComponent {}";
                addCode(code, function (fileName) {
                    ngService.getDiagnostics(fileName);
                });
            }).not.toThrow();
        });
        function addCode(code, cb) {
            var fileName = '/app/app.component.ts';
            var originalContent = mockHost.getFileContent(fileName);
            mockHost.override(fileName, originalContent + code);
            try {
                cb(fileName);
            }
            finally {
                mockHost.override(fileName, undefined);
            }
        }
    });
    function contains(fileName, locationMarker) {
        var names = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            names[_i - 2] = arguments[_i];
        }
        var location = mockHost.getMarkerLocations(fileName)[locationMarker];
        if (location == null) {
            throw new Error("No marker " + locationMarker + " found.");
        }
        expectEntries.apply(void 0, [locationMarker, ngService.getCompletionsAt(fileName, location)].concat(names));
    }
});
function expectEntries(locationMarker, completions) {
    var names = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        names[_i - 2] = arguments[_i];
    }
    var entries = {};
    if (!completions) {
        throw new Error("Expected result from " + locationMarker + " to include " + names.join(', ') + " but no result provided");
    }
    else {
        for (var _a = 0, completions_1 = completions; _a < completions_1.length; _a++) {
            var entry = completions_1[_a];
            entries[entry.name] = true;
        }
        var missing = names.filter(function (name) { return !entries[name]; });
        if (missing.length) {
            throw new Error("Expected result from " + locationMarker + " to include at least one of the following, " + missing.join(', ') + ", in the list of entries " + completions.map(function (entry) { return entry.name; }).join(', '));
        }
    }
}
function buildUp(originalText, cb) {
    var count = originalText.length;
    var inString = (new Array(count)).fill(false);
    var unused = (new Array(count)).fill(1).map(function (v, i) { return i; });
    function getText() {
        return new Array(count).fill(1).map(function (v, i) { return i; }).filter(function (i) { return inString[i]; }).map(function (i) { return originalText[i]; }).join('');
    }
    function randomUnusedIndex() {
        return Math.floor(Math.random() * unused.length);
    }
    var _loop_1 = function() {
        var unusedIndex = randomUnusedIndex();
        var index = unused[unusedIndex];
        if (index == null)
            throw new Error('Internal test buildup error');
        if (inString[index])
            throw new Error('Internal test buildup error');
        inString[index] = true;
        unused.splice(unusedIndex, 1);
        var text = getText();
        var position = inString.filter(function (_, i) { return i <= index; }).map(function (v) { return v ? 1 : 0; }).reduce(function (p, v) { return p + v; }, 0);
        cb(text, position);
    };
    while (unused.length > 0) {
        _loop_1();
    }
}
function noDiagnostics(diagnostics) {
    if (diagnostics && diagnostics.length) {
        throw new Error("Unexpected diagnostics: \n  " + diagnostics.map(function (d) { return d.message; }).join('\n  '));
    }
}
function includeDiagnostic(diagnostics, message, at, len) {
    expect(diagnostics).toBeDefined();
    if (diagnostics) {
        var diagnostic = diagnostics.find(function (d) { return d.message.indexOf(message) >= 0; });
        expect(diagnostic).toBeDefined();
        if (diagnostic && at != null) {
            expect(diagnostic.span.start).toEqual(at);
            if (len != null) {
                expect(diagnostic.span.end - diagnostic.span.start).toEqual(len);
            }
        }
    }
}
//# sourceMappingURL=service_spec.js.map