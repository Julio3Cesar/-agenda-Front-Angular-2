"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ast_1 = require('@angular/compiler/src/expression_parser/ast');
var lexer_1 = require('@angular/compiler/src/expression_parser/lexer');
var parser_1 = require('@angular/compiler/src/expression_parser/parser');
var ast_2 = require('@angular/compiler/src/ml_parser/ast');
var i18n_html_parser_1 = require('@angular/compiler/src/i18n/i18n_html_parser');
var html_parser_1 = require('@angular/compiler/src/ml_parser/html_parser');
var html_tags_1 = require('@angular/compiler/src/ml_parser/html_tags');
var tags_1 = require('@angular/compiler/src/ml_parser/tags');
var parse_util_1 = require('@angular/compiler/src/parse_util');
var dom_element_schema_registry_1 = require('@angular/compiler/src/schema/dom_element_schema_registry');
var selector_1 = require('@angular/compiler/src/selector');
var template_ast_1 = require('@angular/compiler/src/template_parser/template_ast');
var template_parser_1 = require('@angular/compiler/src/template_parser/template_parser');
var html_info_1 = require('./html_info');
var html_path_1 = require('./html_path');
var template_path_1 = require('./template_path');
var utils_1 = require('./utils');
var expressions_1 = require('./expressions');
var extras_1 = require("./extras");
/**
 * The kind of diagnostic message.
 *
 * @experimental
 */
(function (DiagnosticKind) {
    DiagnosticKind[DiagnosticKind["Error"] = 0] = "Error";
    DiagnosticKind[DiagnosticKind["Warning"] = 1] = "Warning";
})(exports.DiagnosticKind || (exports.DiagnosticKind = {}));
var DiagnosticKind = exports.DiagnosticKind;
/**
 * An enumeration of basic types.
 *
 * A `LanguageServiceHost` interface.
 *
 * @experimental
 */
(function (BuiltinType) {
    /**
     * The type is a type that can hold any other type.
     */
    BuiltinType[BuiltinType["Any"] = 0] = "Any";
    /**
     * The type of a string literal.
     */
    BuiltinType[BuiltinType["String"] = 1] = "String";
    /**
     * The type of a numeric literal.
     */
    BuiltinType[BuiltinType["Number"] = 2] = "Number";
    /**
     * The type of the `true` and `false` literals.
     */
    BuiltinType[BuiltinType["Boolean"] = 3] = "Boolean";
    /**
     * The type of the `undefined` literal.
     */
    BuiltinType[BuiltinType["Undefined"] = 4] = "Undefined";
    /**
     * the type of the `null` literal.
     */
    BuiltinType[BuiltinType["Null"] = 5] = "Null";
    /**
     * Not a built-in type.
     */
    BuiltinType[BuiltinType["Other"] = 6] = "Other";
})(exports.BuiltinType || (exports.BuiltinType = {}));
var BuiltinType = exports.BuiltinType;
/**
 * Create an instance of a `LanguageService`.
 *
 * @experimental
 */
function createLanguageService(host) {
    return new LanguageServiceImpl(host);
}
exports.createLanguageService = createLanguageService;
var LanguageServiceImpl = (function () {
    function LanguageServiceImpl(host) {
        this.host = host;
    }
    Object.defineProperty(LanguageServiceImpl.prototype, "metadataResolver", {
        get: function () { return this.host.resolver; },
        enumerable: true,
        configurable: true
    });
    LanguageServiceImpl.prototype.getTemplateReferences = function () {
        return this.host.getTemplateReferences();
    };
    LanguageServiceImpl.prototype.getDiagnostics = function (fileName) {
        var results = new Map;
        if (fileName.endsWith(".ts") || fileName.endsWith(".tsx")) {
            var fileDiags = getFileDiagnostics(fileName);
            fileDiags.push.apply(fileDiags, this.host.getDiagnostics(fileName));
        }
        var templates = this.host.getTemplates(fileName);
        if (templates && templates.length) {
            var _loop_1 = function(template) {
                var templateResults = getFileDiagnostics(template.fileName);
                var ast = this_1.getTemplateAst(template);
                if (ast) {
                    var errors_1 = false;
                    if (ast.parseErrors && ast.parseErrors.length) {
                        templateResults.push.apply(templateResults, extras_1.processAstErrors(ast.parseErrors).map(function (e) {
                            errors_1 = errors_1 || e.level === parse_util_1.ParseErrorLevel.FATAL;
                            return {
                                kind: e.level === parse_util_1.ParseErrorLevel.FATAL ? DiagnosticKind.Error : DiagnosticKind.Warning,
                                span: utils_1.offsetSpan(utils_1.spanOf(e.span), template.span.start),
                                message: e.msg
                            };
                        }));
                    }
                    if (!errors_1) {
                        var expressionDiagnostics = this_1.getExpressionDiagnostics(template, ast);
                        templateResults.push.apply(templateResults, expressionDiagnostics);
                    }
                }
            };
            var this_1 = this;
            for (var _i = 0, templates_1 = templates; _i < templates_1.length; _i++) {
                var template = templates_1[_i];
                _loop_1(template);
            }
        }
        function getFileDiagnostics(fileName) {
            var diags = results.get(fileName);
            if (!diags) {
                diags = [];
                results.set(fileName, diags);
            }
            return diags;
        }
        return results;
    };
    LanguageServiceImpl.prototype.getPipesAt = function (fileName, position) {
        var templateInfo = this.getTemplateAstAtPosition(fileName, position);
        if (templateInfo) {
            return templateInfo.pipes.map(function (pipeInfo) { return ({ name: pipeInfo.name, symbol: pipeInfo.type.reference }); });
        }
    };
    LanguageServiceImpl.prototype.getCompletionsAt = function (fileName, position) {
        var result = undefined;
        var templateInfo = this.getTemplateAstAtPosition(fileName, position);
        if (templateInfo) {
            var htmlAst = templateInfo.htmlAst, templateAst = templateInfo.templateAst, template_1 = templateInfo.template;
            // The templateNode starts at the delimiter character so we add 1 to skip it.
            var templatePosition_1 = position - template_1.span.start;
            var path_1 = new html_path_1.HtmlAstPath(htmlAst, templatePosition_1);
            var mostSpecific = path_1.tail;
            if (path_1.empty) {
                result = this.elementCompletions(templateInfo, path_1);
            }
            else {
                var astPosition_1 = templatePosition_1 - mostSpecific.sourceSpan.start.offset;
                var _this_1 = this;
                mostSpecific.visit({
                    visitElement: function (ast) {
                        var startTagSpan = utils_1.spanOf(ast.sourceSpan);
                        var tagLen = ast.name.length;
                        if (templatePosition_1 <=
                            startTagSpan.start + tagLen + 1 /* 1 for the opening angle bracked */) {
                            // If we are in the tag then return the element completions.
                            result = _this_1.elementCompletions(templateInfo, path_1);
                        }
                        else if (templatePosition_1 < startTagSpan.end) {
                            // We are in the attribute section of the element (but not in an attribute).
                            // Return
                            // the attribute completions.
                            result = _this_1.attributeCompletions(templateInfo, path_1);
                        }
                    },
                    visitAttribute: function (ast) {
                        if (!ast.valueSpan || !utils_1.inSpan(templatePosition_1, utils_1.spanOf(ast.valueSpan))) {
                            // We are in the name of an attribute. Show attribute completions.
                            result = _this_1.attributeCompletions(templateInfo, path_1);
                        }
                        else if (ast.valueSpan && utils_1.inSpan(templatePosition_1, utils_1.spanOf(ast.valueSpan))) {
                            result = _this_1.attributeValueCompletions(templateInfo, templatePosition_1, ast);
                        }
                    },
                    visitText: function (ast) {
                        // Check if we are in a entity.
                        result = _this_1.entityCompletions(getSourceText(template_1, utils_1.spanOf(ast)), astPosition_1);
                        if (result)
                            return result;
                        result = _this_1.interpolationCompletions(templateInfo, templatePosition_1);
                        if (result)
                            return result;
                        var element = path_1.first(ast_2.Element);
                        if (element) {
                            var definition = html_tags_1.getHtmlTagDefinition(element.name);
                            if (definition.contentType === tags_1.TagContentType.PARSABLE_DATA) {
                                result = _this_1.voidElementAttributeCompletions(templateInfo, path_1);
                                if (!result) {
                                    // If the element can hold content Show element completions.
                                    result = _this_1.elementCompletions(templateInfo, path_1);
                                }
                            }
                        }
                        else {
                            // If no element container, implies parsable data so show elements.
                            result = _this_1.voidElementAttributeCompletions(templateInfo, path_1);
                            if (!result) {
                                result = _this_1.elementCompletions(templateInfo, path_1);
                            }
                        }
                    },
                    visitComment: function (ast) { },
                    visitExpansion: function (ast) { },
                    visitExpansionCase: function (ast) { }
                }, null);
            }
        }
        return result;
    };
    LanguageServiceImpl.prototype.entityCompletions = function (value, position) {
        // Look for entity completions
        var re = /&[A-Za-z]*;?(?!\d)/g;
        var found;
        var result;
        while (found = re.exec(value)) {
            var len = found[0].length;
            if (position >= found.index && position < (found.index + len)) {
                result = Object.keys(tags_1.NAMED_ENTITIES)
                    .map(function (name) { return ({ kind: 'entity', name: "&" + name + ";", sort: name }); });
                break;
            }
        }
        return result;
    };
    LanguageServiceImpl.prototype.interpolationCompletions = function (info, position) {
        var _this = this;
        // Look for an interpolation in at the position.
        var templatePath = new template_path_1.TemplateAstPath(info.templateAst, position);
        var mostSpecific = templatePath.tail;
        if (mostSpecific) {
            var visitor = new ExpressionVisitor(info, position, undefined, function () { return _this.getExpressionScope(info, templatePath, false); });
            mostSpecific.visit(visitor, null);
            return uniqueByName(visitor.result);
        }
    };
    LanguageServiceImpl.prototype.elementCompletions = function (info, path) {
        var htmlNames = html_info_1.elementNames().filter(function (name) { return !(name in hiddenHtmlElements); });
        // Collect the elements referenced by the selectors
        var directiveElements = getSelectors(info).selectors.map(function (selector) { return selector.element; }).filter(function (name) { return !!name; });
        var components = directiveElements.map(function (name) { return ({ kind: 'component', name: name, sort: name }); });
        var htmlElements = htmlNames.map(function (name) { return ({ kind: 'element', name: name, sort: name }); });
        // Return components and html elements
        return uniqueByName(htmlElements.concat(components));
    };
    // There is a special case of HTML where text that contains a unclosed tag is treated as
    // text. For exaple '<h1> Some <a text </h1>' produces a text nodes inside of the H1
    // element "Some <a text". We, however, want to treat this as if the user was requesting
    // the attributes of an "a" element, not requesting completion in the a text element. This
    // code checks for this case and returns element completions if it is detected or undefined
    // if it is not.
    LanguageServiceImpl.prototype.voidElementAttributeCompletions = function (info, path) {
        var tail = path.tail;
        if (tail instanceof ast_2.Text) {
            var match = tail.value.match(/<(\w(\w|\d|-)*:)?(\w(\w|\d|-)*)\s/);
            // The position must be after the match, otherwise we are still in a place where elements
            // are expected (such as `<|a` or `<a|`; we only want attributes for `<a |` or after).
            if (match && path.position >= match.index + match[0].length + tail.sourceSpan.start.offset) {
                return this.attributeCompletionsForElement(info, match[3]);
            }
        }
    };
    LanguageServiceImpl.prototype.getAttributeInfosForElement = function (info, elementName, element) {
        var attributes = [];
        // Add html attributes
        var htmlAttributes = html_info_1.attributeNames(elementName) || [];
        if (htmlAttributes) {
            attributes.push.apply(attributes, htmlAttributes.map(function (name) { return ({ name: name, fromHtml: true }); }));
        }
        // Add DOM properties
        var htmlProperties = html_info_1.propertyNames(elementName);
        if (htmlProperties) {
            attributes.push.apply(attributes, htmlProperties.map(function (name) { return ({ name: name, input: true }); }));
        }
        // Add DOM events
        var htmlEvents = html_info_1.eventNames(elementName);
        if (htmlEvents) {
            attributes.push.apply(attributes, htmlEvents.map(function (name) { return ({ name: name, output: true }); }));
        }
        var _a = getSelectors(info), selectors = _a.selectors, selectorMap = _a.map;
        if (selectors && selectors.length) {
            // All the attributes that are selectable should be shown.
            var applicableSelectors = selectors.filter(function (selector) { return !selector.element || selector.element == elementName; });
            var selectorAndAttributeNames = applicableSelectors.map(function (selector) { return ({ selector: selector, attrs: selector.attrs.filter(function (a) { return !!a; }) }); });
            var attrs_1 = flatten(selectorAndAttributeNames.map(function (selectorAndAttr) {
                var directive = selectorMap.get(selectorAndAttr.selector);
                var result = selectorAndAttr.attrs.map(function (name) { return ({ name: name, input: name in directive.inputs, output: name in directive.outputs }); });
                return result;
            }));
            // Add template attribute if a directive contains a template reference
            selectorAndAttributeNames.forEach(function (selectorAndAttr) {
                var selector = selectorAndAttr.selector;
                var directive = selectorMap.get(selector);
                if (directive && hasTemplateReference(directive.type) && selector.attrs.length && selector.attrs[0]) {
                    attrs_1.push({ name: selector.attrs[0], template: true });
                }
            });
            // All input and output properties of the matching directives should be added.
            var elementSelector = element ? createElementCssSelector(element) :
                createElementCssSelector(new ast_2.Element(elementName, [], [], undefined, undefined, undefined));
            var matcher = new selector_1.SelectorMatcher();
            matcher.addSelectables(selectors);
            matcher.match(elementSelector, function (selector) {
                var directive = selectorMap.get(selector);
                if (directive) {
                    attrs_1.push.apply(attrs_1, Object.keys(directive.inputs).map(function (name) { return ({ name: name, input: true }); }));
                    attrs_1.push.apply(attrs_1, Object.keys(directive.outputs).map(function (name) { return ({ name: name, output: true }); }));
                }
            });
            // If a name shows up twice, fold it into a single value.
            attrs_1 = foldAttrs(attrs_1);
            // Now expand them back out to ensure that input/output shows up as well as input and
            // output.
            attributes.push.apply(attributes, flatten(attrs_1.map(expandedAttr)));
        }
        return attributes;
    };
    LanguageServiceImpl.prototype.attributeCompletionsForElement = function (info, elementName, element) {
        var attributes = this.getAttributeInfosForElement(info, elementName, element);
        // Map all the attributes to a completion
        return attributes.map(function (attr) { return ({ kind: attr.fromHtml ? 'html attribute' : 'attribute', name: nameOfAttr(attr), sort: attr.name }); });
    };
    LanguageServiceImpl.prototype.attributeCompletions = function (info, path) {
        var item = path.tail instanceof ast_2.Element ? path.tail : path.parentOf(path.tail);
        if (item instanceof ast_2.Element) {
            return this.attributeCompletionsForElement(info, item.name, item);
        }
        return undefined;
    };
    LanguageServiceImpl.prototype.attributeValueCompletions = function (info, position, attr) {
        var _this = this;
        var path = new template_path_1.TemplateAstPath(info.templateAst, position);
        var mostSpecific = path.pop();
        while (mostSpecific
            && (!(mostSpecific instanceof template_ast_1.BoundDirectivePropertyAst
                || mostSpecific instanceof template_ast_1.BoundElementPropertyAst
                || mostSpecific instanceof template_ast_1.BoundEventAst
                || mostSpecific instanceof template_ast_1.BoundTextAst)
                || !this.sameSpan(attr.sourceSpan, mostSpecific.sourceSpan))) {
            if (mostSpecific instanceof template_ast_1.AttrAst) {
                //simple attribute without any bindings, just return
                return;
            }
            if (mostSpecific instanceof template_ast_1.ElementAst) {
                //*ngFor/If/etc.
                break;
            }
            mostSpecific = path.pop();
        }
        if (mostSpecific) {
            var visitor = new ExpressionVisitor(info, position, attr, function () { return _this.getExpressionScope(info, path, false); });
            mostSpecific.visit(visitor, null);
            return visitor.result;
        }
    };
    LanguageServiceImpl.prototype.sameSpan = function (span1, span2) {
        return span1 && span2
            && span1.start && span1.end
            && span2.start && span2.end
            && span1.start.offset == span2.start.offset
            && span1.start.offset == span2.start.offset;
    };
    LanguageServiceImpl.prototype.getExpressionScope = function (info, path, includeEvent) {
        var result = info.template.members;
        var references = getReferences(info);
        var variables = getVarDeclarations(info, path);
        var events = getEventDeclaration(info, path, includeEvent);
        if (references.length || variables.length || events.length) {
            var referenceTable = info.template.query.createSymbolTable(references);
            var variableTable = info.template.query.createSymbolTable(variables);
            var eventsTable = info.template.query.createSymbolTable(events);
            result = info.template.query.mergeSymbolTable([result, referenceTable, variableTable, eventsTable]);
        }
        return result;
    };
    LanguageServiceImpl.prototype.getTemplateAstAtPosition = function (fileName, position) {
        var template = this.host.getTemplateAt(fileName, position);
        if (template) {
            var astResult = this.getTemplateAst(template);
            if (astResult && astResult.htmlAst && astResult.templateAst)
                return {
                    template: template,
                    htmlAst: astResult.htmlAst,
                    directive: astResult.directive,
                    directives: astResult.directives,
                    pipes: astResult.pipes,
                    templateAst: astResult.templateAst,
                    expressionParser: astResult.expressionParser
                };
        }
        return undefined;
    };
    LanguageServiceImpl.prototype.getTemplateAst = function (template) {
        var result;
        try {
            var directive = this.metadataResolver.getDirectiveMetadata(template.type);
            if (directive) {
                var rawHtmlParser = new html_parser_1.HtmlParser();
                var htmlParser = new i18n_html_parser_1.I18NHtmlParser(rawHtmlParser);
                var expressionParser = new parser_1.Parser(new lexer_1.Lexer());
                var parser = new template_parser_1.TemplateParser(expressionParser, new dom_element_schema_registry_1.DomElementSchemaRegistry(), htmlParser, null, []);
                var htmlResult = htmlParser.parse(template.source, '');
                var moduleSummary = this.host.getModuleSummary();
                var errors = undefined;
                var ngModule = moduleSummary.ngModuleByComponent.get(template.type);
                if (!ngModule) {
                    errors = [{ kind: DiagnosticKind.Error, message: "Component '" + directive.type.name + "' is not in a module" }];
                    ngModule = findSuitableDefaultModule(moduleSummary);
                }
                if (ngModule) {
                    var directives = ngModule.transitiveModule.directives;
                    var pipes = ngModule.transitiveModule.pipes;
                    var schemas = ngModule.schemas;
                    var parseResult = parser.tryParseHtml(htmlResult, directive, template.source, directives, pipes, schemas, '');
                    result = {
                        htmlAst: htmlResult.rootNodes,
                        templateAst: parseResult.templateAst, directive: directive, directives: directives, pipes: pipes,
                        parseErrors: parseResult.errors, expressionParser: expressionParser,
                        errors: errors
                    };
                }
            }
        }
        catch (e) {
            result = { errors: [{ kind: DiagnosticKind.Error, message: e.stack, span: template.span }] };
        }
        return result;
    };
    LanguageServiceImpl.prototype.getExpressionDiagnostics = function (template, astResult) {
        var _this = this;
        var info = {
            template: template,
            htmlAst: astResult.htmlAst,
            directive: astResult.directive,
            directives: astResult.directives,
            pipes: astResult.pipes,
            templateAst: astResult.templateAst || [],
            expressionParser: astResult.expressionParser
        };
        var visitor = new ExpressionDiagnosticsVisitor(info, function (path, includeEvent) { return _this.getExpressionScope(info, path, includeEvent); }, function (elementName, element) { return _this.getAttributeInfosForElement(info, elementName, element); });
        if (astResult.templateAst) {
            template_ast_1.templateVisitAll(visitor, astResult.templateAst);
        }
        return visitor.diagnostics;
    };
    return LanguageServiceImpl;
}());
var TEMPLATE_ATTR_PREFIX = '*';
function lowerName(name) {
    return name && (name[0].toLowerCase() + name.substr(1));
}
var ExpressionVisitor = (function (_super) {
    __extends(ExpressionVisitor, _super);
    function ExpressionVisitor(info, position, attr, getExpressionScope) {
        _super.call(this);
        this.info = info;
        this.position = position;
        this.attr = attr;
        this.getExpressionScope = getExpressionScope;
        if (!getExpressionScope) {
            this.getExpressionScope = function () { return info.template.members; };
        }
    }
    ExpressionVisitor.prototype.visitDirectiveProperty = function (ast) {
        this.attributeValueCompletions(ast.value);
    };
    ExpressionVisitor.prototype.visitElementProperty = function (ast) {
        this.attributeValueCompletions(ast.value);
    };
    ExpressionVisitor.prototype.visitEvent = function (ast) {
        this.attributeValueCompletions(ast.handler);
    };
    ExpressionVisitor.prototype.visitElement = function (ast) {
        var _this = this;
        if (this.attr && getSelectors(this.info) && this.attr.name.startsWith(TEMPLATE_ATTR_PREFIX)) {
            // The value is a template expression but the expression AST was not produced when the TemplateAst was produce so
            // do that now.
            var key = this.attr.name.substr(TEMPLATE_ATTR_PREFIX.length);
            // Find the selector
            var selectorInfo = getSelectors(this.info);
            var selectors = selectorInfo.selectors;
            var selector_2 = selectors.filter(function (s) { return s.attrs.some(function (attr, i) { return i % 2 == 0 && attr == key; }); })[0];
            var templateBindingResult = this.info.expressionParser.parseTemplateBindings(key + ' ' + this.attr.value, null, 0);
            // find the template binding that contains the position
            var valueRelativePosition = this.position - this.attr.valueSpan.start.offset - 1;
            var templateBindingRelativePosition_1 = valueRelativePosition + key.length + 1;
            var bindings = templateBindingResult.templateBindings;
            var binding = bindings.find(function (binding) { return utils_1.inSpan(templateBindingRelativePosition_1, binding.span, /* exclusive */ true); }) ||
                bindings.find(function (binding) { return utils_1.inSpan(templateBindingRelativePosition_1, binding.span); });
            var keyCompletions = function () {
                var keys = [];
                if (selector_2) {
                    var attrNames = selector_2.attrs.filter(function (_, i) { return i % 2 == 0; });
                    keys = attrNames.filter(function (name) { return name.startsWith(key) && name != key; }).map(function (name) { return lowerName(name.substr(key.length)); });
                }
                keys.push('let');
                _this.result = keys.map(function (key) { return { kind: 'key', name: key, sort: key }; });
            };
            if (!binding || (binding.key == key && !binding.expression)) {
                // We are in the root binding. We should return `let` and keys that are left in the selector.
                keyCompletions();
            }
            else if (binding.keyIsVar) {
                var equalLocation = this.attr.value.indexOf('=');
                this.result = [];
                if (equalLocation >= 0 && valueRelativePosition >= equalLocation) {
                    // We are after the '=' in a let clause. The valid values here are the members of the template reference's type parameter.
                    var directiveMetadata = selectorInfo.map.get(selector_2);
                    var contextTable = this.info.template.query.getTemplateContext(directiveMetadata.type.reference);
                    if (contextTable) {
                        this.result = this.symbolsToCompletions(contextTable.values());
                    }
                }
                else if (binding.key && valueRelativePosition <= (binding.key.length - key.length)) {
                    keyCompletions();
                }
            }
            else {
                // If the position is in the expression or after the key or there is no key, return the expression completions
                if ((binding.expression && utils_1.inSpan(templateBindingRelativePosition_1, binding.expression.ast.span)) ||
                    (binding.key && templateBindingRelativePosition_1 > binding.span.start + (binding.key.length - key.length)) ||
                    !binding.key) {
                    var span = new ast_1.ParseSpan(0, this.attr.value.length);
                    this.attributeValueCompletions(binding.expression ? binding.expression.ast : new ast_1.PropertyRead(span, new ast_1.ImplicitReceiver(span), ''), templateBindingRelativePosition_1);
                }
                else {
                    keyCompletions();
                }
            }
        }
    };
    ExpressionVisitor.prototype.visitBoundText = function (ast) {
        var expressionPosition = this.position - ast.sourceSpan.start.offset;
        if (utils_1.inSpan(expressionPosition, ast.value.span)) {
            var completions = expressions_1.getExpressionCompletions(this.getExpressionScope(), ast.value, expressionPosition, this.info.template.query);
            if (completions) {
                this.result = this.symbolsToCompletions(completions);
            }
        }
    };
    ExpressionVisitor.prototype.attributeValueCompletions = function (value, position) {
        var symbols = expressions_1.getExpressionCompletions(this.getExpressionScope(), value, position == null ? this.attributeValuePosition : position, this.info.template.query);
        if (symbols) {
            this.result = this.symbolsToCompletions(symbols);
        }
    };
    ExpressionVisitor.prototype.symbolsToCompletions = function (symbols) {
        return symbols.filter(function (s) { return !s.name.startsWith('__') && s.public; }).map(function (symbol) { return { kind: symbol.kind, name: symbol.name, sort: symbol.name }; });
    };
    Object.defineProperty(ExpressionVisitor.prototype, "attributeValuePosition", {
        get: function () {
            return this.position - this.attr.valueSpan.start.offset - 1;
        },
        enumerable: true,
        configurable: true
    });
    return ExpressionVisitor;
}(template_path_1.NullTemplateVisitor));
var ExpressionDiagnosticsVisitor = (function (_super) {
    __extends(ExpressionDiagnosticsVisitor, _super);
    function ExpressionDiagnosticsVisitor(info, getExpressionScope, getAttributeInfosForElement) {
        _super.call(this);
        this.info = info;
        this.getExpressionScope = getExpressionScope;
        this.getAttributeInfosForElement = getAttributeInfosForElement;
        this.diagnostics = [];
        this.path = new template_path_1.TemplateAstPath([], 0);
    }
    ExpressionDiagnosticsVisitor.prototype.visitBoundText = function (ast) {
        this.push(ast);
        this.diagnoseExpression(ast.value, ast.sourceSpan.start.offset, false);
        this.pop();
    };
    ExpressionDiagnosticsVisitor.prototype.visitDirectiveProperty = function (ast) {
        this.push(ast);
        //TODO properly resolve scope for validation of generated expressions
        if (ast.sourceSpan.details === null) {
            this.diagnoseExpression(ast.value, this.attributeValueLocation(ast), false);
        }
        this.pop();
    };
    ExpressionDiagnosticsVisitor.prototype.visitElementProperty = function (ast) {
        this.push(ast);
        //TODO properly resolve scope for validation of generated expressions
        if (ast.sourceSpan.details === null) {
            this.diagnoseExpression(ast.value, this.attributeValueLocation(ast), false);
        }
        this.pop();
    };
    ExpressionDiagnosticsVisitor.prototype.visitEvent = function (ast) {
        this.push(ast);
        //TODO properly resolve scope for validation of generated expressions
        if (ast.sourceSpan.details === null) {
            this.diagnoseExpression(ast.handler, this.attributeValueLocation(ast), true);
        }
        this.pop();
    };
    ExpressionDiagnosticsVisitor.prototype.visitVariable = function (ast) {
        var directive = this.templateDirective;
        if (directive && ast.value) {
            var context = this.info.template.query.getTemplateContext(directive.type.reference);
            if (!context.has(ast.value)) {
                if (ast.value === '$implicit') {
                    this.reportError('The template context does not have an implicit value', utils_1.spanOf(ast.sourceSpan));
                }
                else {
                    this.reportError("The template context does not defined a member called '" + ast.value + "'", utils_1.spanOf(ast.sourceSpan));
                }
            }
        }
    };
    ExpressionDiagnosticsVisitor.prototype.visitElement = function (ast, context) {
        this.push(ast);
        _super.prototype.visitElement.call(this, ast, context);
        this.pop();
    };
    ExpressionDiagnosticsVisitor.prototype.visitEmbeddedTemplate = function (ast, context) {
        var previousTemplateDirective = this.templateDirective;
        this.push(ast);
        // Find directive that refernces this template
        this.templateDirective = ast.directives.map(function (d) { return d.directive; }).find(function (d) { return hasTemplateReference(d.type); });
        // Process children
        _super.prototype.visitEmbeddedTemplate.call(this, ast, context);
        this.pop();
        this.templateDirective = previousTemplateDirective;
    };
    ExpressionDiagnosticsVisitor.prototype.visitAttr = function (ast) {
        var element = this.path.tail;
        var attrName = ast.name;
        if (!(element instanceof template_ast_1.ElementAst) || !element.name
            || attrName === "class" || attrName === "style") {
            return;
        }
        var msg = html_info_1.validateAttribute(attrName);
        if (msg) {
            this.reportError(msg, { start: ast.sourceSpan.start.offset, end: ast.sourceSpan.start.offset + attrName.length });
            return;
        }
        var infos = this.getAttributeInfosForElement(element.name, element);
        var caseNotMatch = false;
        var found = infos.find(function (info) { return info.name === attrName
            || info.name.toLowerCase() === attrName.toLowerCase(); });
        if (!found || (!found.input && !found.fromHtml)) {
            this.reportWarning("Unknown attribute '" + attrName + "'.", { start: ast.sourceSpan.start.offset, end: ast.sourceSpan.start.offset + attrName.length });
        }
    };
    ExpressionDiagnosticsVisitor.prototype.attributeValueLocation = function (ast) {
        var path = new html_path_1.HtmlAstPath(this.info.htmlAst, ast.sourceSpan.start.offset);
        var last = path.tail;
        if (last instanceof ast_2.Attribute && last.valueSpan) {
            // Add 1 for the quote.
            return last.valueSpan.start.offset + 1;
        }
        return ast.sourceSpan.start.offset;
    };
    ExpressionDiagnosticsVisitor.prototype.diagnoseExpression = function (ast, offset, includeEvent) {
        var _this = this;
        var scope = this.getExpressionScope(this.path, includeEvent);
        (_a = this.diagnostics).push.apply(_a, expressions_1.getExpressionDiagnostics(scope, ast, this.info.template.query).map(function (d) { return ({
            span: utils_1.offsetSpan(d.ast.span, offset + _this.info.template.span.start),
            kind: d.kind,
            message: d.message,
            fileName: _this.info.template.fileName
        }); }));
        var _a;
    };
    ExpressionDiagnosticsVisitor.prototype.push = function (ast) {
        this.path.push(ast);
    };
    ExpressionDiagnosticsVisitor.prototype.pop = function () {
        this.path.pop();
    };
    ExpressionDiagnosticsVisitor.prototype.selectors = function () {
        var result = this._selectors;
        if (!result) {
            this._selectors = result = getSelectors(this.info);
        }
        return result;
    };
    ExpressionDiagnosticsVisitor.prototype.findElement = function (position) {
        var htmlPath = new html_path_1.HtmlAstPath(this.info.htmlAst, position);
        if (htmlPath.tail instanceof ast_2.Element) {
            return htmlPath.tail;
        }
    };
    ExpressionDiagnosticsVisitor.prototype.reportError = function (message, span) {
        this.diagnostics.push({ span: utils_1.offsetSpan(span, this.info.template.span.start), kind: DiagnosticKind.Error, message: message });
    };
    ExpressionDiagnosticsVisitor.prototype.reportWarning = function (message, span) {
        this.diagnostics.push({ span: utils_1.offsetSpan(span, this.info.template.span.start), kind: DiagnosticKind.Warning, message: message });
    };
    return ExpressionDiagnosticsVisitor;
}(template_path_1.TemplateAstChildVisitor));
function getSourceText(template, span) {
    return template.source.substring(span.start, span.end);
}
var hiddenHtmlElements = {
    html: true,
    script: true,
    noscript: true,
    base: true,
    body: true,
    title: true,
    head: true,
    link: true,
};
function flatten(a) {
    return (_a = []).concat.apply(_a, a);
    var _a;
}
function expandedAttr(attr) {
    if (attr.input && attr.output) {
        return [
            attr, { name: attr.name, input: true, output: false },
            { name: attr.name, input: false, output: true }
        ];
    }
    return [attr];
}
function removeSuffix(value, suffix) {
    if (value.endsWith(suffix))
        return value.substring(0, value.length - suffix.length);
    return value;
}
function nameOfAttr(attr) {
    var name = attr.name;
    if (attr.output) {
        name = removeSuffix(name, 'Events');
        name = removeSuffix(name, 'Changed');
    }
    var result = [name];
    if (attr.input) {
        result.unshift('[');
        result.push(']');
    }
    if (attr.output) {
        result.unshift('(');
        result.push(')');
    }
    if (attr.template) {
        result.unshift('*');
    }
    return result.join('');
}
function foldAttrs(attrs) {
    var inputOutput = new Map();
    var templates = new Map();
    var result = [];
    attrs.forEach(function (attr) {
        if (attr.fromHtml) {
            return attr;
        }
        if (attr.template) {
            var duplicate = templates.get(attr.name);
            if (!duplicate) {
                result.push({ name: attr.name, template: true });
                templates.set(attr.name, attr);
            }
        }
        if (attr.input || attr.output) {
            var duplicate = inputOutput.get(attr.name);
            if (duplicate) {
                duplicate.input = duplicate.input || attr.input;
                duplicate.output = duplicate.output || attr.output;
            }
            else {
                var cloneAttr = { name: attr.name };
                if (attr.input)
                    cloneAttr.input = true;
                if (attr.output)
                    cloneAttr.output = true;
                result.push(cloneAttr);
                inputOutput.set(attr.name, cloneAttr);
            }
        }
    });
    return result;
}
function hasTemplateReference(type) {
    if (type.diDeps) {
        for (var _i = 0, _a = type.diDeps; _i < _a.length; _i++) {
            var diDep = _a[_i];
            if (diDep.token.identifier && diDep.token.identifier.name == 'TemplateRef')
                return true;
        }
    }
    return false;
}
var templateAttr = /^(\w+:)?(template$|^\*)/;
function createElementCssSelector(element) {
    var cssSelector = new selector_1.CssSelector();
    var elNameNoNs = tags_1.splitNsName(element.name)[1];
    cssSelector.setElement(elNameNoNs);
    for (var _i = 0, _a = element.attrs; _i < _a.length; _i++) {
        var attr = _a[_i];
        if (!attr.name.match(templateAttr)) {
            var _b = tags_1.splitNsName(attr.name), _ = _b[0], attrNameNoNs = _b[1];
            cssSelector.addAttribute(attrNameNoNs, attr.value);
            if (attr.name.toLowerCase() == 'class') {
                var classes = attr.value.split(/s+/g);
                classes.forEach(function (className) { return cssSelector.addClassName(className); });
            }
        }
    }
    return cssSelector;
}
function getSelectors(info) {
    var map = new Map();
    var selectors = flatten(info.directives.map(function (directive) {
        var selectors = selector_1.CssSelector.parse(directive.selector);
        selectors.forEach(function (selector) { return map.set(selector, directive); });
        return selectors;
    }));
    return { selectors: selectors, map: map };
}
// Collect let variable declarations
function getVarDeclarations(info, path) {
    var result = [];
    var current = path.tail;
    while (current) {
        if (current instanceof template_ast_1.EmbeddedTemplateAst) {
            for (var _i = 0, _a = current.variables; _i < _a.length; _i++) {
                var variable = _a[_i];
                var name_1 = variable.name;
                // Find the first directive with a context.
                var context = current.directives.map(function (d) { return info.template.query.getTemplateContext(d.directive.type.reference); }).find(function (c) { return !!c; });
                // Determine the type of the context field referenced by variable.value.
                var type = void 0;
                if (context) {
                    var value = context.get(variable.value);
                    if (value) {
                        type = value.type;
                    }
                }
                if (!type) {
                    type = info.template.query.getBuiltinType(BuiltinType.Any);
                }
                result.push({ name: name_1, kind: 'variable', type: type });
            }
        }
        current = path.parentOf(current);
    }
    return result;
}
// Produce an event declaration or empty declarations
function getEventDeclaration(info, path, includeEvent) {
    var result = [];
    if (includeEvent) {
        // TODO: Determine the type of the event parameter based on the Observable<T> or EventEmitter<T> of the event.
        result = [{ name: '$event', kind: 'variable', type: info.template.query.getBuiltinType(BuiltinType.Any) }];
    }
    return result;
}
// Collect references
function getReferences(info) {
    var result = [];
    function processReferences(references) {
        for (var _i = 0, references_1 = references; _i < references_1.length; _i++) {
            var reference = references_1[_i];
            var type = void 0;
            if (reference.value) {
                type = info.template.query.getTypeSymbol(reference.value.reference);
            }
            result.push({ name: reference.name, kind: 'reference', type: type || info.template.query.getBuiltinType(BuiltinType.Any) });
        }
    }
    var visitor = new (function (_super) {
        __extends(class_1, _super);
        function class_1() {
            _super.apply(this, arguments);
        }
        class_1.prototype.visitEmbeddedTemplate = function (ast, context) {
            _super.prototype.visitEmbeddedTemplate.call(this, ast, context);
            processReferences(ast.references);
        };
        class_1.prototype.visitElement = function (ast, context) {
            _super.prototype.visitElement.call(this, ast, context);
            processReferences(ast.references);
        };
        return class_1;
    }(template_path_1.TemplateAstChildVisitor));
    template_ast_1.templateVisitAll(visitor, info.templateAst);
    return result;
}
function elementMatchesDirective(element, directive) {
    var directiveSelector = selector_1.CssSelector.parse(directive.selector);
    return directiveSelector.find(function (selector) { return selector.attrs.find(function (attr) { return element.attrs.find(function (a) { return a.name == TEMPLATE_ATTR_PREFIX + attr; }) != null; }) != null; }) != null;
}
function validKeysOf(key, directive) {
    var validKeys = new Set();
    validKeys.add(key);
    for (var input in directive.inputs) {
        if (input.startsWith(key)) {
            validKeys.add(lowerName(input.substr(key.length)));
        }
    }
    return validKeys;
}
function uniqueByName(elements) {
    if (elements) {
        var result = [];
        var set = new Set();
        for (var _i = 0, elements_1 = elements; _i < elements_1.length; _i++) {
            var element_1 = elements_1[_i];
            if (!set.has(element_1.name)) {
                set.add(element_1.name);
                result.push(element_1);
            }
        }
        return result;
    }
}
function findSuitableDefaultModule(summary) {
    var result;
    var resultSize = 0;
    for (var _i = 0, _a = summary.ngModules; _i < _a.length; _i++) {
        var module_1 = _a[_i];
        var moduleSize = module_1.transitiveModule.directives.length;
        if (moduleSize > resultSize) {
            result = module_1;
            resultSize = moduleSize;
        }
    }
    return result;
}
//# sourceMappingURL=service.js.map