"use strict";
require('reflect-metadata');
var ts = require('typescript');
var plugin_1 = require('../src/plugin');
var test_data_1 = require('./test_data');
var test_utils_1 = require('./test_utils');
describe('plugin', function () {
    var documentRegistry = ts.createDocumentRegistry();
    var mockHost = new test_utils_1.MockTypescriptHost(['/app/main.ts', '/app/parsing-cases.ts'], test_data_1.toh);
    var service = ts.createLanguageService(mockHost, documentRegistry);
    var program = service.getProgram();
    it('should not report errors on tour of heroes', function () {
        expectNoDiagnostics(service.getCompilerOptionsDiagnostics());
        for (var _i = 0, _a = program.getSourceFiles(); _i < _a.length; _i++) {
            var source = _a[_i];
            expectNoDiagnostics(service.getSyntacticDiagnostics(source.fileName));
            expectNoDiagnostics(service.getSemanticDiagnostics(source.fileName));
        }
    });
    var plugin = new plugin_1.LanguageServicePlugin({ ts: ts, host: mockHost, service: service, registry: documentRegistry, basePath: "" });
    it('should not report template errors on tour of heroes', function () {
        for (var _i = 0, _a = program.getSourceFiles(); _i < _a.length; _i++) {
            var source = _a[_i];
            // Ignore all 'cases.ts' files as they intentionally contain errors.
            if (!source.fileName.endsWith('cases.ts'))
                expectNoDiagnostics(plugin.getSemanticDiagnosticsFilter(source.fileName, []));
        }
    });
    it('should be able to get entity completions', function () {
        contains('app/app.component.ts', 'entity-amp', '&amp;', '&gt;', '&lt;', '&iota;');
    });
    it('should be able to return html elements', function () {
        var htmlTags = ['h1', 'h2', 'div', 'span'];
        var locations = ['empty', 'start-tag-h1', 'h1-content', 'start-tag', 'start-tag-after-h'];
        for (var _i = 0, locations_1 = locations; _i < locations_1.length; _i++) {
            var location_1 = locations_1[_i];
            contains.apply(void 0, ['app/app.component.ts', location_1].concat(htmlTags));
        }
    });
    it('should be able to return element diretives', function () { contains('app/app.component.ts', 'empty', 'my-app'); });
    it('should be able to return h1 attributes', function () { contains('app/app.component.ts', 'h1-after-space', 'id', 'dir', 'lang', 'onclick'); });
    it('should be able to find common angular attributes', function () {
        contains('app/app.component.ts', 'div-attributes', '(click)', '[ngClass]', '*ngIf', '*ngFor');
    });
    it('should be able to returned attribute names with an incompete attribute', function () {
        contains('app/parsing-cases.ts', 'no-value-attribute', 'id', 'dir', 'lang');
    });
    it('should be able to return attributes of an incomplete element', function () {
        contains('app/parsing-cases.ts', 'incomplete-open-lt', 'a');
        contains('app/parsing-cases.ts', 'incomplete-open-a', 'a');
        contains('app/parsing-cases.ts', 'incomplete-open-attr', 'id', 'dir', 'lang');
    });
    it('should be able to return completions with a missing closing tag', function () { contains('app/parsing-cases.ts', 'missing-closing', 'h1', 'h2'); });
    it('should be able to return common attributes of in an unknown tag', function () { contains('app/parsing-cases.ts', 'unknown-element', 'id', 'dir', 'lang'); });
    it('should be able to get the completions at the beginning of an interpolation', function () {
        contains('app/app.component.ts', 'h2-hero', 'hero', 'title');
    });
    it('should not include private members of the of a class', function () {
        contains('app/app.component.ts', 'h2-hero', '-internal');
    });
    it('should be able to get the completions at the end of an interpolation', function () {
        contains('app/app.component.ts', 'sub-end', 'hero', 'title');
    });
    it('should be able to get the completions in a property read', function () {
        contains('app/app.component.ts', 'h2-name', 'name', 'id');
    });
    it('should be able to get a list of pipe values', function () {
        contains('app/parsing-cases.ts', 'before-pipe', 'lowercase', 'uppercase');
        contains('app/parsing-cases.ts', 'in-pipe', 'lowercase', 'uppercase');
        contains('app/parsing-cases.ts', 'after-pipe', 'lowercase', 'uppercase');
    });
    it('should be able get completions in an empty interpolation', function () {
        contains('app/parsing-cases.ts', 'empty-interpolation', 'title', 'subTitle');
    });
    describe("with attributes", function () {
        it('should be able to complete property value', function () {
            contains('app/parsing-cases.ts', 'property-binding-model', 'test');
        });
        it('should be able to complete an event', function () {
            contains('app/parsing-cases.ts', 'event-binding-model', 'modelChanged');
        });
        it('should be able to complete a two-way binding', function () {
            contains('app/parsing-cases.ts', 'two-way-binding-model', 'test');
        });
    });
    describe('with a *ngFor', function () {
        it('should include a let for empty attribute', function () {
            contains('app/parsing-cases.ts', 'for-empty', 'let');
        });
        it('should not suggest any entries if in the name part of a let', function () {
            expectEmpty('app/parsing-cases.ts', 'for-let-empty');
        });
        it('should suggest NgForRow members for let initialization expression', function () {
            contains('app/parsing-cases.ts', 'for-let-i-equal', 'index', 'count', 'first', 'last', 'even', 'odd');
        });
        it('should include a let', function () {
            contains('app/parsing-cases.ts', 'for-let', 'let');
        });
        it('should include an "of"', function () {
            contains('app/parsing-cases.ts', 'for-of', 'of');
        });
        it('should include field reference', function () {
            contains('app/parsing-cases.ts', 'for-people', 'people');
        });
        it('should include person in the let scope', function () {
            contains('app/parsing-cases.ts', 'for-interp-person', 'person');
        });
        // TODO: Enable when we can infer the element type of the ngFor
        // it('should include determine person\'s type as Person', () => {
        //   contains('app/parsing-cases.ts', 'for-interp-name', 'name', 'age');
        //   contains('app/parsing-cases.ts', 'for-interp-age', 'name', 'age');
        // });
    });
    describe('for pipes', function () {
        it('should be able to resolve lowercase', function () {
            contains('app/expression-cases.ts', 'string-pipe', 'substring');
        });
    });
    describe('with references', function () {
        it('should list references', function () {
            contains('app/parsing-cases.ts', 'test-comp-content', 'test1', 'test2', 'div');
        });
        it('should reference the component', function () {
            contains('app/parsing-cases.ts', 'test-comp-after-test', 'name');
        });
        // TODO: Enable when we have a flag that indicates the project targets the DOM
        // it('should refernce the element if no component', () => {
        //   contains('app/parsing-cases.ts', 'test-comp-after-div', 'innerText');
        // });
    });
    describe('for semantic errors', function () {
        it('should report access to an unknown field', function () {
            expectSemanticError('app/expression-cases.ts', 'foo', "Identifier 'foo' is not defined. The component declaration, template variable declarations, and element references do not contain such a member");
        });
        it('should report access to an unknown sub-field', function () {
            expectSemanticError('app/expression-cases.ts', 'nam', "Identifier 'nam' is not defined. 'Person' does not contain such a member");
        });
        it('should report access to a private member', function () {
            expectSemanticError('app/expression-cases.ts', 'myField', "Identifier 'myField' refers to a private member of the component");
        });
        it('should report numeric operator erros', function () {
            expectSemanticError('app/expression-cases.ts', 'mod', "Expected a numeric type");
        });
        describe('in ngFor', function () {
            function expectError(locationMarker, message) {
                expectSemanticError('app/ng-for-cases.ts', locationMarker, message);
            }
            it('should report an unknown field', function () {
                expectError('people_1', "Identifier 'people_1' is not defined. The component declaration, template variable declarations, and element references do not contain such a member");
            });
            it('should report an unknown context reference', function () {
                expectError('even_1', "The template context does not defined a member called 'even_1'");
            });
            it('should report an unknown value in a key expression', function () {
                expectError('trackBy_1', "Identifier 'trackBy_1' is not defined. The component declaration, template variable declarations, and element references do not contain such a member");
            });
        });
        describe('in ngIf', function () {
            function expectError(locationMarker, message) {
                expectSemanticError('app/ng-if-cases.ts', locationMarker, message);
            }
            it('should report an implicit context reference', function () {
                expectError('implicit', 'The template context does not have an implicit value');
            });
        });
    });
    function getMarkerLocation(fileName, locationMarker) {
        var location = mockHost.getMarkerLocations(fileName)[locationMarker];
        if (location == null) {
            throw new Error("No marker " + locationMarker + " found.");
        }
        return location;
    }
    function contains(fileName, locationMarker) {
        var names = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            names[_i - 2] = arguments[_i];
        }
        var location = getMarkerLocation(fileName, locationMarker);
        expectEntries.apply(void 0, [locationMarker, plugin.getCompletionsAtPosition(fileName, location)].concat(names));
    }
    function expectEmpty(fileName, locationMarker) {
        var location = getMarkerLocation(fileName, locationMarker);
        expect(plugin.getCompletionsAtPosition(fileName, location).entries).toEqual([]);
    }
    function expectSemanticError(fileName, locationMarker, message) {
        var start = getMarkerLocation(fileName, locationMarker);
        var end = getMarkerLocation(fileName, locationMarker + '-end');
        var errors = plugin.getSemanticDiagnosticsFilter(fileName, []);
        for (var _i = 0, errors_1 = errors; _i < errors_1.length; _i++) {
            var error = errors_1[_i];
            if (error.messageText.toString().indexOf(message) >= 0) {
                expect(error.start).toEqual(start);
                expect(error.length).toEqual(end - start);
                return;
            }
        }
        throw new Error("Expected error messages to contain " + message + ", in messages:\n  " + errors.map(function (e) { return e.messageText.toString(); }).join(',\n  '));
    }
});
function expectEntries(locationMarker, info) {
    var names = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        names[_i - 2] = arguments[_i];
    }
    var entries = {};
    if (!info) {
        throw new Error("Expected result from " + locationMarker + " to include " + names.join(', ') + " but no result provided");
    }
    else {
        for (var _a = 0, _b = info.entries; _a < _b.length; _a++) {
            var entry = _b[_a];
            entries[entry.name] = true;
        }
        var shouldContains = names.filter(function (name) { return !name.startsWith('-'); });
        var shouldNotContain = names.filter(function (name) { return name.startsWith('-'); });
        var missing = shouldContains.filter(function (name) { return !entries[name]; });
        var present = shouldNotContain.map(function (name) { return name.substr(1); }).filter(function (name) { return entries[name]; });
        if (missing.length) {
            throw new Error("Expected result from " + locationMarker + " to include at least one of the following, " + missing.join(', ') + ", in the list of entries " + info.entries.map(function (entry) { return entry.name; }).join(', '));
        }
        if (present.length) {
            throw new Error("Unexpected member" + (present.length > 1 ? 's' : '') + " included in result: " + present.join(', '));
        }
    }
}
function expectNoDiagnostics(diagnostics) {
    for (var _i = 0, diagnostics_1 = diagnostics; _i < diagnostics_1.length; _i++) {
        var diagnostic = diagnostics_1[_i];
        var message = ts.flattenDiagnosticMessageText(diagnostic.messageText, '\n');
        if (diagnostic.start) {
            var _a = diagnostic.file.getLineAndCharacterOfPosition(diagnostic.start), line = _a.line, character = _a.character;
            console.log(diagnostic.file.fileName + " (" + (line + 1) + "," + (character + 1) + "): " + message);
        }
        else {
            console.log("" + message);
        }
    }
    expect(diagnostics.length).toBe(0);
}
//# sourceMappingURL=plugin_spec.js.map